/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package computationalintelligencealgorithm;

import java.util.Random;
import sun.misc.FpUtils;

/**
 *
 * @author Jam Jahanzeb
 */
public class ExplorationAndExploitation {

    Cost parent1;
    Cost parent2;

    public ExplorationAndExploitation(Cost parent1, Cost parent2) {
        this.parent1 = parent1;
        this.parent2 = parent2;
    }

    public ExplorationAndExploitation(Cost parent1) {
        this.parent1 = parent1;
    }

    public void crossOverOfTwoParent(double maxValueOfX, double minValueOfX, double maxValueOfY, double minValueOfY, int type, boolean gaussian) {
        double temp = this.parent1.getValueofX();
        this.parent1.setValueofX(this.parent2.getValueofX());
        this.parent2.setValueofX(temp);

        this.mutationOfTheParents(maxValueOfX, minValueOfX, maxValueOfY, minValueOfY, type, gaussian);
    }

    public Cost newParent1() {
        return this.parent1;
    }

    public Cost newParent2() {
        return this.parent2;
    }

    public void mutationOfTheParents(double maxValueOfX, double minValueOfX, double maxValueOfY, double minValueOfY, int type, boolean gaussian) {

        int maximumValue = 5;
        int minimumValue = -5;
        int rangeValue = 100;

        double X1 = this.parent1.getValueofX();
        double Y1 = this.parent1.getValueofY();

        double changeInX1;
        double changeInY1;

        if (gaussian) {
            do {
                changeInX1 = (Math.pow((-2 * Math.log(getARandomNumberBetween(minimumValue, maximumValue) / rangeValue)), 0.5)) * (Math.cos(2 * Math.PI * (getARandomNumberBetween(minimumValue, maximumValue) / rangeValue)));
            } while (!FpUtils.isFinite(changeInX1));

            do {
                changeInY1 = (Math.pow((-2 * Math.log(getARandomNumberBetween(minimumValue, maximumValue) / rangeValue)), 0.5)) * (Math.sin(2 * Math.PI * (getARandomNumberBetween(minimumValue, maximumValue) / rangeValue)));
            } while (!FpUtils.isFinite(changeInY1));

        } else {
            changeInX1 = getARandomNumberBetween(minimumValue, maximumValue) / rangeValue;
            changeInY1 = getARandomNumberBetween(minimumValue, maximumValue) / rangeValue;
        }

        if (type == 1) {
            double the20PercentRule = getARandomNumberBetween(1, 10000) / 10000;

            if (the20PercentRule < 0.2) {
                X1 += changeInX1;

                if (X1 > maxValueOfX) {
                    X1 = maxValueOfX;
                } else if (X1 < minValueOfX) {
                    X1 = minValueOfX;
                }
            }

            the20PercentRule = getARandomNumberBetween(1, 10000) / 10000;
            if (the20PercentRule < 0.2) {
                Y1 += changeInY1;

                if (Y1 > maxValueOfY) {
                    Y1 = maxValueOfY;
                } else if (Y1 < minValueOfY) {
                    Y1 = minValueOfY;
                }
            }
        } else {

            double alleleMutationRule = getARandomNumberBetween(1, 10000) / 10000;

            if (alleleMutationRule < 0.1) {
                X1 += changeInX1;

                if (X1 > maxValueOfX) {
                    X1 = maxValueOfX;
                } else if (X1 < minValueOfX) {
                    X1 = minValueOfX;
                }
            }

            alleleMutationRule = getARandomNumberBetween(1, 10000) / 10000;

            if (alleleMutationRule < 0.1) {
                Y1 += changeInY1;

                if (Y1 > maxValueOfY) {
                    Y1 = maxValueOfY;
                } else if (Y1 < minValueOfY) {
                    Y1 = minValueOfY;
                }
            }
        }
        parent1.setValueofX((X1));
        parent1.setValueofY((Y1));

        double X2 = this.parent2.getValueofX();
        double Y2 = this.parent2.getValueofY();

        double changeInX2;
        double changeInY2;

        if (gaussian) {
            do {
                changeInX2 = (Math.pow((-2 * Math.log(getARandomNumberBetween(minimumValue, maximumValue) / rangeValue)), 0.5)) * (Math.cos(2 * Math.PI * (getARandomNumberBetween(minimumValue, maximumValue) / rangeValue)));
            } while (!FpUtils.isFinite(changeInX1));

            do {
                changeInY2 = (Math.pow((-2 * Math.log(getARandomNumberBetween(minimumValue, maximumValue) / rangeValue)), 0.5)) * (Math.sin(2 * Math.PI * (getARandomNumberBetween(minimumValue, maximumValue) / rangeValue)));
            } while (!FpUtils.isFinite(changeInY1));

        } else {
            changeInX2 = getARandomNumberBetween(minimumValue, maximumValue) / rangeValue;
            changeInY2 = getARandomNumberBetween(minimumValue, maximumValue) / rangeValue;
        }

        if (type == 1) {
            double the20PercentRule = getARandomNumberBetween(1, 10000) / 10000;

            if (the20PercentRule < 0.2) {
                X2 += changeInX2;

                if (X2 > maxValueOfX) {
                    X2 = maxValueOfX;
                } else if (X2 < minValueOfX) {
                    X2 = minValueOfX;
                }
            }

            the20PercentRule = getARandomNumberBetween(1, 10000) / 10000;

            if (the20PercentRule < 0.2) {
                Y2 += changeInY2;

                if (Y2 > maxValueOfY) {
                    Y2 = maxValueOfY;
                } else if (Y2 < minValueOfY) {
                    Y2 = minValueOfY;
                }
            }
        } else {

            double alleleMutationRule = getARandomNumberBetween(1, 10000) / 10000;

            if (alleleMutationRule < 0.1) {
                X2 += changeInX2;

                if (X2 > maxValueOfX) {
                    X2 = maxValueOfX;
                } else if (X2 < minValueOfX) {
                    X2 = minValueOfX;
                }
            }

            alleleMutationRule = getARandomNumberBetween(1, 10000) / 10000;

            if (alleleMutationRule < 0.1) {
                Y2 += changeInY2;

                if (Y2 > maxValueOfY) {
                    Y2 = maxValueOfY;
                } else if (Y2 < minValueOfY) {
                    Y2 = minValueOfY;
                }
            }
        }
        parent2.setValueofX((X2));
        parent2.setValueofY((Y2));
    }

    public void AISMutation(double maxValueOfX, double minValueOfX, double maxValueOfY, double minValueOfY, int functionValue) {

        int maximumValue = 5;
        int minimumValue = -5;
        int rangeValue = 100;

        double X1 = this.parent1.getValueofX();
        double Y1 = this.parent1.getValueofY();

        double changeInX1;
        double changeInY1;

        changeInX1 = getARandomNumberBetween(minimumValue, maximumValue) / rangeValue;
        changeInY1 = getARandomNumberBetween(minimumValue, maximumValue) / rangeValue;

        double mutationRule = getARandomNumberBetween(1, 10000) / 10000;

        if (mutationRule < (0.1 / this.parent1.getCost(functionValue))) {
            X1 += changeInX1;

            if (X1 > maxValueOfX) {
                X1 = maxValueOfX;
            } else if (X1 < minValueOfX) {
                X1 = minValueOfX;
            }
        }

        mutationRule = getARandomNumberBetween(1, 10000) / 10000;

        if (mutationRule < (0.1 / this.parent1.getCost(functionValue))) {
            Y1 += changeInY1;

            if (Y1 > maxValueOfY) {
                Y1 = maxValueOfY;
            } else if (Y1 < minValueOfY) {
                Y1 = minValueOfY;
            }
        }

        parent1.setValueofX((X1));
        parent1.setValueofY((Y1));
    }

    public static double getARandomNumberBetween(int minimumValue, int maximumValue) {

        Random randomNumber = new Random();
        int newRandomNumber = randomNumber.nextInt((maximumValue - minimumValue) + 1) + minimumValue;

        return newRandomNumber;
    }
}
